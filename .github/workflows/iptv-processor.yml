name: IPTV Channel Processing

on:
  # æ¯å¤©UTCæ—¶é—´1:00è‡ªåŠ¨è¿è¡Œ
  schedule:
    - cron: '0 1 * * *'
  # æ”¯æŒæ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
  # å½“å·¥ä½œæµæ–‡ä»¶æ›´æ”¹æ—¶ä¹Ÿè¿è¡Œ
  push:
    paths:
      - '.github/workflows/iptv-processor.yml'

permissions:
  # è®¾ç½®ä»“åº“è¯»å†™æƒé™
  contents: write

jobs:
  process-iptv:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
        
    - name: Create Python processing script
      run: |
        cat > process_iptv.py << 'EOF'
        #!/usr/bin/env python3
        import re
        import requests
        import time
        from datetime import datetime
        
        # ç”¨æˆ·ä»£ç†ï¼Œé¿å…è¢«å±è”½
        HEADERS = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        }
        
        def download_m3u(url, retries=3):
            """ä¸‹è½½M3Uæ–‡ä»¶ï¼Œæ”¯æŒé‡è¯•"""
            for attempt in range(retries):
                try:
                    print(f"æ­£åœ¨ä¸‹è½½: {url}")
                    response = requests.get(url, headers=HEADERS, timeout=30)
                    response.raise_for_status()
                    
                    # æ£€æŸ¥å†…å®¹æ˜¯å¦æœ‰æ•ˆ
                    content = response.text
                    if '#EXTM3U' in content or '#EXTINF' in content:
                        print(f"ä¸‹è½½æˆåŠŸï¼Œå†…å®¹å¤§å°: {len(content)} å­—ç¬¦")
                        return content
                    else:
                        print(f"è­¦å‘Š: ä¸‹è½½çš„å†…å®¹å¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„M3Uæ–‡ä»¶")
                        return content
                        
                except Exception as e:
                    print(f"ä¸‹è½½å¤±è´¥ (å°è¯• {attempt+1}/{retries}): {e}")
                    if attempt < retries - 1:
                        time.sleep(2)
                    else:
                        print(f"æ‰€æœ‰é‡è¯•å¤±è´¥ï¼Œè·³è¿‡æ­¤æº")
                        return None
        
        def parse_m3u_channels(content):
            """è§£æžM3Uå†…å®¹ï¼Œæå–é¢‘é“ä¿¡æ¯"""
            channels = []
            
            if not content:
                return channels
                
            lines = content.split('\n')
            current_channel = {}
            
            for i, line in enumerate(lines):
                line = line.strip()
                
                # å¤„ç†EXTINFè¡Œ
                if line.startswith('#EXTINF:'):
                    current_channel = {
                        'extinf': line,
                        'name': '',
                        'group': '',
                        'url': ''
                    }
                    
                    # æå–é¢‘é“åç§°
                    name_match = re.search(r',(.*)', line)
                    if name_match:
                        current_channel['name'] = name_match.group(1).strip()
                    
                    # æå–åˆ†ç»„ä¿¡æ¯
                    group_match = re.search(r'group-title="([^"]+)"', line)
                    if group_match:
                        current_channel['group'] = group_match.group(1)
                    else:
                        # å°è¯•å…¶ä»–æ ¼å¼çš„åˆ†ç»„
                        group_match2 = re.search(r'group-title=([^,]+)', line)
                        if group_match2:
                            current_channel['group'] = group_match2.group(1).replace('"', '')
                            
                # å¤„ç†URLè¡Œ
                elif line and not line.startswith('#') and current_channel and 'url' not in current_channel:
                    current_channel['url'] = line
                    channels.append(current_channel.copy())
                    current_channel = {}
            
            print(f"è§£æžåˆ° {len(channels)} ä¸ªé¢‘é“")
            return channels
        
        def process_source1(channels):
            """å¤„ç†ç¬¬ä¸€ä¸ªæºçš„é¢‘é“"""
            categories = {
                'å¤®è§†é¢‘é“': [],
                'å«è§†é¢‘é“': [],
                'å¤®è§†å’ªå’•': [],
                'å«è§†å’ªå’•': []
            }
            
            for channel in channels:
                name = channel.get('name', '')
                
                # è½¬æ¢ä¸ºå°å†™ä¾¿äºŽåŒ¹é…
                name_lower = name.lower()
                
                # æ£€æŸ¥æ˜¯å¦åŒ…å«cctvå’ŒMCP
                if 'cctv' in name_lower and 'mcp' in name_lower:
                    categories['å¤®è§†é¢‘é“'].append(channel)
                
                # æ£€æŸ¥æ˜¯å¦åŒ…å«å«è§†å’ŒMCP
                elif 'å«è§†' in name and 'MCP' in name:
                    categories['å«è§†é¢‘é“'].append(channel)
                
                # æ£€æŸ¥æ˜¯å¦åŒ…å«CCTVï¼ˆå¤®è§†å’ªå’•ï¼‰
                elif 'CCTV' in name and 'MCP' not in name:
                    categories['å¤®è§†å’ªå’•'].append(channel)
                
                # æ£€æŸ¥æ˜¯å¦åŒ…å«å«è§†ï¼ˆå«è§†å’ªå’•ï¼‰
                elif 'å«è§†' in name and 'MCP' not in name:
                    categories['å«è§†å’ªå’•'].append(channel)
            
            print(f"æº1å¤„ç†ç»“æžœ:")
            for cat, chs in categories.items():
                print(f"  {cat}: {len(chs)} ä¸ªé¢‘é“")
                
            return categories
        
        def process_source2(channels):
            """å¤„ç†ç¬¬äºŒä¸ªæºçš„é¢‘é“"""
            categories = {
                'æ¸¸æˆèµ›äº‹': [],
                'è™Žç‰™å½±è§†': [],
                'å’ªè§†ç•Œbc': [],
                'å†°èŒ¶ä½“è‚²': [],
                'å‡¤å‡°é¢‘é“': [],
                'å½±è§†é¢‘é“': []
            }
            
            for channel in channels:
                group = channel.get('group', '')
                name = channel.get('name', '')
                
                # æ ¹æ®åˆ†ç»„è¿›è¡Œåˆ†ç±»
                if 'æ¸¸æˆèµ›äº‹' in group:
                    categories['æ¸¸æˆèµ›äº‹'].append(channel)
                elif 'è™Žç‰™å½±è§†' in group:
                    categories['è™Žç‰™å½±è§†'].append(channel)
                elif 'å’ªè§†ç•Œbc' in group:
                    categories['å’ªè§†ç•Œbc'].append(channel)
                elif 'å†°èŒ¶ä½“è‚²' in group:
                    categories['å†°èŒ¶ä½“è‚²'].append(channel)
                elif 'ç²¤è¯­é¢‘é“' in group:
                    # æå–ç‰¹å®šçš„å‡¤å‡°é¢‘é“
                    if any(phoenix in name for phoenix in ['å‡¤å‡°ä¸­æ–‡', 'å‡¤å‡°èµ„è®¯', 'å‡¤å‡°é¦™æ¸¯']):
                        categories['å‡¤å‡°é¢‘é“'].append(channel)
                elif 'å…¶ä»–é¢‘é“' in group:
                    categories['å½±è§†é¢‘é“'].append(channel)
            
            print(f"æº2å¤„ç†ç»“æžœ:")
            for cat, chs in categories.items():
                print(f"  {cat}: {len(chs)} ä¸ªé¢‘é“")
                
            return categories
        
        def create_m3u_output(categories_list):
            """åˆ›å»ºæœ€ç»ˆçš„M3Uè¾“å‡º"""
            # M3Uå¤´éƒ¨
            output = '#EXTM3U x-tvg-url=""\n'
            output += f'# Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n'
            output += f'# Source1: https://live.ottiptv.cc/iptv.m3u\n'
            output += f'# Source2: https://bc.188766.xyz/\n\n'
            
            total_channels = 0
            
            # éåŽ†æ‰€æœ‰åˆ†ç±»
            for categories in categories_list:
                for category_name, channels in categories.items():
                    if channels:
                        output += f'# {category_name}\n'
                        for channel in channels:
                            # ä¿®æ”¹åˆ†ç»„åç§°ä¸ºå½“å‰åˆ†ç±»
                            extinf = re.sub(
                                r'group-title="[^"]+"',
                                f'group-title="{category_name}"',
                                channel['extinf']
                            )
                            # å¦‚æžœåŽŸå§‹æ²¡æœ‰group-titleï¼Œæ·»åŠ ä¸€ä¸ª
                            if 'group-title' not in extinf:
                                extinf = extinf.replace('#EXTINF:', f'#EXTINF: group-title="{category_name}" ')
                            
                            output += f'{extinf}\n'
                            output += f'{channel["url"]}\n\n'
                            total_channels += 1
            
            output += f'# Total channels: {total_channels}\n'
            return output, total_channels
        
        def main():
            print("å¼€å§‹å¤„ç†IPTVé¢‘é“...")
            print("=" * 50)
            
            all_categories = []
            
            # å¤„ç†ç¬¬ä¸€ä¸ªæº
            print("\n[å¤„ç†æº1]")
            url1 = "https://live.ottiptv.cc/iptv.m3u?userid=8137863657&sign=2c8d82c9f17f480726d4770be9d0fb33fd0fcb31e1024448c36663605ea6a3f99e5bd467b68c287e3f0c07f85b95a188139aa3f19e227e251dc707bce0ededaab73ceeaddf6195&auth_token=54741b289e946919fc1c34ca88db58a4"
            content1 = download_m3u(url1)
            
            if content1:
                channels1 = parse_m3u_channels(content1)
                categories1 = process_source1(channels1)
                all_categories.append(categories1)
            else:
                print("æº1å¤„ç†å¤±è´¥ï¼Œè·³è¿‡")
            
            # å¤„ç†ç¬¬äºŒä¸ªæº
            print("\n[å¤„ç†æº2]")
            url2 = "https://bc.188766.xyz/?url=https://live.188766.xyz&mishitong=true&mima=mianfeibuhuaqian&huikan=1"
            content2 = download_m3u(url2)
            
            if content2:
                channels2 = parse_m3u_channels(content2)
                categories2 = process_source2(channels2)
                all_categories.append(categories2)
            else:
                print("æº2å¤„ç†å¤±è´¥ï¼Œè·³è¿‡")
            
            # ç”Ÿæˆæœ€ç»ˆçš„M3Uæ–‡ä»¶
            if all_categories:
                print("\n[ç”Ÿæˆæœ€ç»ˆM3Uæ–‡ä»¶]")
                m3u_content, total_channels = create_m3u_output(all_categories)
                
                # ä¿å­˜åˆ°æ–‡ä»¶
                with open('iptv.m3u', 'w', encoding='utf-8') as f:
                    f.write(m3u_content)
                
                print(f"âœ“ å·²ç”Ÿæˆ iptv.m3u")
                print(f"âœ“ æ€»é¢‘é“æ•°: {total_channels}")
                
                # ç»Ÿè®¡å„åˆ†ç±»é¢‘é“æ•°
                print("\n[é¢‘é“åˆ†ç±»ç»Ÿè®¡]")
                for categories in all_categories:
                    for cat_name, channels in categories.items():
                        if channels:
                            print(f"  {cat_name}: {len(channels)} ä¸ªé¢‘é“")
            else:
                print("é”™è¯¯: æ²¡æœ‰æˆåŠŸå¤„ç†ä»»ä½•æº")
                return False
            
            print("\n" + "=" * 50)
            print("å¤„ç†å®Œæˆ!")
            return True
        
        if __name__ == "__main__":
            success = main()
            exit(0 if success else 1)
        EOF
        
    - name: Run IPTV processing script
      run: python process_iptv.py
      
    - name: Create README file
      run: |
        # èŽ·å–å½“å‰æ—¶é—´
        CURRENT_TIME=$(date +"%Y-%m-%d %H:%M:%S UTC")
        
        # ç»Ÿè®¡é¢‘é“æ•°é‡
        if [ -f "iptv.m3u" ]; then
          CHANNEL_COUNT=$(grep -c "^#EXTINF:" iptv.m3u || echo "0")
        else
          CHANNEL_COUNT="0"
        fi
        
        cat > README.md << EOF
        # IPTV é¢‘é“åˆ—è¡¨
        
        æ­¤ä»“åº“è‡ªåŠ¨æ•´åˆä¸¤ä¸ªIPTVæºçš„é¢‘é“ï¼Œå¹¶æŒ‰åˆ†ç±»æ•´ç†ã€‚
        
        ## ðŸ“º æœ€æ–°æ’­æ”¾åˆ—è¡¨
        
        ä¸»æ–‡ä»¶: [iptv.m3u](iptv.m3u)
        
        ### ç›´æŽ¥æ’­æ”¾é“¾æŽ¥
        \`\`\`
        https://raw.githubusercontent.com/${{ github.repository }}/main/iptv.m3u
        \`\`\`
        
        ## ðŸ“Š ç»Ÿè®¡ä¿¡æ¯
        
        - **æœ€åŽæ›´æ–°æ—¶é—´**: ${CURRENT_TIME}
        - **æ€»é¢‘é“æ•°é‡**: ${CHANNEL_COUNT} ä¸ª
        - **æ›´æ–°é¢‘çŽ‡**: æ¯å¤©è‡ªåŠ¨æ›´æ–°
        
        ## ðŸ”§ å¤„ç†è§„åˆ™
        
        ### æº1å¤„ç†è§„åˆ™
        1. **å¤®è§†é¢‘é“**: é¢‘é“åç§°åŒ…å« "cctv" å’Œ "MCP"
        2. **å«è§†é¢‘é“**: é¢‘é“åç§°åŒ…å« "å«è§†" å’Œ "MCP"
        3. **å¤®è§†å’ªå’•**: é¢‘é“åç§°åŒ…å« "CCTV"
        4. **å«è§†å’ªå’•**: é¢‘é“åç§°åŒ…å« "å«è§†"
        
        ### æº2å¤„ç†è§„åˆ™
        1. **æ¸¸æˆèµ›äº‹**: é¢‘é“åˆ†ç»„ä¸º "æ¸¸æˆèµ›äº‹"
        2. **è™Žç‰™å½±è§†**: é¢‘é“åˆ†ç»„ä¸º "è™Žç‰™å½±è§†"
        3. **å’ªè§†ç•Œbc**: é¢‘é“åˆ†ç»„ä¸º "å’ªè§†ç•Œbc"
        4. **å†°èŒ¶ä½“è‚²**: é¢‘é“åˆ†ç»„ä¸º "å†°èŒ¶ä½“è‚²"
        5. **å‡¤å‡°é¢‘é“**: ç²¤è¯­é¢‘é“ä¸­çš„å‡¤å‡°ä¸­æ–‡ã€å‡¤å‡°èµ„è®¯ã€å‡¤å‡°é¦™æ¸¯
        6. **å½±è§†é¢‘é“**: é¢‘é“åˆ†ç»„ä¸º "å…¶ä»–é¢‘é“"
        
        ## ðŸš€ ä½¿ç”¨æ–¹æ³•
        
        1. **ä¸‹è½½æ–‡ä»¶**: ç›´æŽ¥ä¸‹è½½ [iptv.m3u](iptv.m3u)
        2. **åœ¨çº¿æ’­æ”¾**: å¤åˆ¶ä¸Šè¿°ç›´æŽ¥æ’­æ”¾é“¾æŽ¥åˆ°æ”¯æŒM3Uçš„æ’­æ”¾å™¨
        3. **æœ¬åœ°æ’­æ”¾**: ç”¨VLCã€PotPlayerç­‰æ’­æ”¾å™¨æ‰“å¼€æ–‡ä»¶
        
        ## âš™ï¸ è‡ªåŠ¨æ›´æ–°
        
        æ­¤åˆ—è¡¨é€šè¿‡ GitHub Actions è‡ªåŠ¨ç»´æŠ¤ï¼š
        - æ¯å¤© UTC æ—¶é—´ 1:00 è‡ªåŠ¨è¿è¡Œ
        - æ”¯æŒæ‰‹åŠ¨è§¦å‘æ›´æ–°
        - è‡ªåŠ¨æäº¤æ›´æ–°åˆ°ä»“åº“
        
        ## ðŸ“ æ–‡ä»¶è¯´æ˜Ž
        
        - \`iptv.m3u\`: æ•´åˆåŽçš„å®Œæ•´æ’­æ”¾åˆ—è¡¨
        - \`process_iptv.py\`: å¤„ç†è„šæœ¬
        - \`README.md\`: è¯´æ˜Žæ–‡æ¡£
        
        ---
        
        *æœ€åŽæ›´æ–°äºŽ ${CURRENT_TIME}*
        EOF
        
    - name: Commit and push changes
      run: |
        # é…ç½®Git
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # æ·»åŠ ç”Ÿæˆçš„æ–‡ä»¶
        git add iptv.m3u
        git add process_iptv.py
        git add README.md
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
        if git diff --cached --quiet; then
          echo "æ²¡æœ‰æ›´æ”¹éœ€è¦æäº¤"
        else
          # æäº¤æ›´æ”¹
          git commit -m "ðŸ”§ æ›´æ–°IPTVé¢‘é“åˆ—è¡¨ - $(date +'%Y-%m-%d %H:%M:%S')"
          
          # æŽ¨é€åˆ°ä»“åº“
          git push
          echo "æ›´æ”¹å·²æäº¤å¹¶æŽ¨é€"
        fi
